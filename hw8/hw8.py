import numpy as np
import cv2, math, sys, os
from pprint import pprint
import matplotlib.pyplot as plt
from PIL import Image, ImageDraw

def validPixel(x, bound):
	return (x >= 0 and x <= bound)

def Dilation(img, kernel):
	imageW, imageH = img.shape
	new_img = np.zeros((imageW, imageH), dtype='int32')
	for x in range(imageW):
		for y in range(imageH):
			localMaximum = 0
			for [ex, ey] in kernel:
				dest_x, dest_y = x + ex, y + ey
				if ( validPixel(dest_x, imageW-1) and validPixel(dest_y, imageH-1) ):
					localMaximum = max( localMaximum, img[dest_x, dest_y])
			new_img[x, y] = localMaximum
	return new_img

def Erosion(img, kernel):
	imageW, imageH = img.shape
	new_img = np.zeros((imageW, imageH), dtype='int32')
	for x in range(imageW):
		for y in range(imageH):
			localMinimum = 255
			for [ex, ey] in kernel:
				dest_x, dest_y = x + ex, y + ey
				if ( validPixel(dest_x, imageW-1) and validPixel(dest_y, imageH-1) ): # valid pixel
					localMinimum = min( localMinimum, img[dest_x, dest_y]) # erosion
			new_img[x, y] = localMinimum
	return new_img

def Opening(img, kernel):
	return Dilation(Erosion(img, kernel), kernel)

def Closing(img, kernel):
	return Erosion(Dilation(img, kernel), kernel)

def generate_gaussian_noise_img(img, mu, sigma, amp):
	img_res = img + amp * np.random.normal(mu, sigma, img.shape)
	for x in range(img.shape[0]):
		for y in range(img.shape[1]):
			if img_res[x][y] > 255: img_res[x][y] = 255 
			if img_res[x][y] < 0: img_res[x][y] = 0 
	return img_res

def generate_salt_and_pepper(img, prob):
	distribution_map = np.random.uniform(0, 1, img.shape)
	imageW, imageH = img.shape[0], img.shape[1]
	img_res = img.copy() #np.zeros((imageW, imageH), dtype='int32')
	for x in range(imageW):
		for y in range(imageH):
			if distribution_map[x][y] < prob: img_res[x][y] = 0
			elif distribution_map[x][y] > 1 - prob: img_res[x][y] = 255
	return img_res

def computeSNR(img, img_res, img_res_name):
	signal, noise = img / 255, img_res / 255
	signal_mean, noise_mean, signal_var, noise_var = np.mean(signal), 0, 0, 0
	imageW, imageH = img.shape
	for x in range(imageW):
		for y in range(imageH):
			noise_mean += (noise[x][y] - signal[x][y])
	noise_mean = noise_mean / ( imageW * imageH )
	for x in range(imageW):
		for y in range(imageH):
			signal_var += math.pow(signal[x][y] - signal_mean, 2)
			noise_var += math.pow((noise[x][y] - signal[x][y]) - noise_mean, 2)
	signal_var = signal_var / ( imageW * imageH )
	noise_var = noise_var / ( imageW * imageH )
	SNR_val = 20 * math.log( math.sqrt(signal_var) / math.sqrt(noise_var), 10)
	print("SNR of image %s is %f" % (img_res_name, SNR_val))

def boxFilter(img, kernel_size):
	imageW, imageH = img.shape
	img_res = np.zeros((imageW, imageH), dtype='int32')
	normalization_term = kernel_size * kernel_size
	kernel = []
	for x in range(-kernel_size//2, kernel_size//2):
		for y in range(-kernel_size//2, kernel_size//2):
			kernel.append([x,y])	
	for x in range(imageW):
		for y in range(imageH):
			for [dx, dy] in kernel:
				if x+dx >= 0 and x+dx < imageW and y+dy >= 0 and y+dy < imageH:
					img_res[x][y] += img[x+dx][y+dy]
			img_res[x][y] = img_res[x][y] / normalization_term
	return img_res

def medianFilter(img, kernel_size):
	imageW, imageH = img.shape
	img_res = np.zeros((imageW, imageH), dtype='int32')
	kernel = []
	for x in range(-kernel_size//2, kernel_size//2):
		for y in range(-kernel_size//2, kernel_size//2):
			kernel.append([x,y])	
	for x in range(imageW):
		for y in range(imageH):
			pixel_vals = []
			for [dx, dy] in kernel:
				if x+dx >= 0 and x+dx < imageW and y+dy >= 0 and y+dy < imageH:
					pixel_vals.append(img[x+dx][y+dy])
			img_res[x][y] = np.median(pixel_vals)
	return img_res

if __name__ == '__main__':
	img = cv2.imread("./lena.bmp", cv2.IMREAD_GRAYSCALE)

	# (a) Generate noisy images with gaussian noise(amplitude of 10 and 30)
	amp_10_img = generate_gaussian_noise_img(img, 0, 1, 10)
	cv2.imwrite('gaussian_noise_amp_10.png', amp_10_img)
	amp_30_img = generate_gaussian_noise_img(img, 0, 1, 30)
	cv2.imwrite('gaussian_noise_amp_30.png', amp_30_img)
	computeSNR(img, amp_10_img, "amp_10_img")
	computeSNR(img, amp_30_img, "amp_30_img")

	# (b) Generate noisy images with salt-and-pepper noise( probability 0.1 and 0.05)
	salt_and_pepper_010 = generate_salt_and_pepper(img, 0.10)
	cv2.imwrite('salt_and_pepper_010.png', salt_and_pepper_010)
	salt_and_pepper_005 = generate_salt_and_pepper(img, 0.05)
	cv2.imwrite('salt_and_pepper_005.png', salt_and_pepper_005)
	computeSNR(img, salt_and_pepper_005, "salt_and_pepper_005")
	computeSNR(img, salt_and_pepper_010, "salt_and_pepper_010")
	
	# (c) Use the 3x3, 5x5 box filter on images generated by (a)(b)
	imgs_name = ["gaussian_noise_amp_10", "gaussian_noise_amp_30", "salt_and_pepper_010", "salt_and_pepper_005"]
	imgs = [amp_10_img, amp_30_img, salt_and_pepper_010, salt_and_pepper_005]
	kernel_sizes = [3,5]
	for (current_img_name, current_img) in zip(imgs_name, imgs):
		for kernel_size in kernel_sizes:
			img_res_name = current_img_name + "_boxFilter_" + str(kernel_size) + ".png"
			img_res = boxFilter(current_img, kernel_size)
			computeSNR(img, img_res, img_res_name)
			cv2.imwrite(img_res_name, img_res)

	# (d) Use 3x3, 5x5 median filter on images generated by (a)(b)
	imgs_name = ["gaussian_noise_amp_10", "gaussian_noise_amp_30", "salt_and_pepper_010", "salt_and_pepper_005"]
	imgs = [amp_10_img, amp_30_img, salt_and_pepper_010, salt_and_pepper_005]
	kernel_sizes = [3,5]
	for (current_img_name, current_img) in zip(imgs_name, imgs):
		for kernel_size in kernel_sizes:
			img_res_name = current_img_name + "_medianFilter_" + str(kernel_size) + ".png"
			img_res = medianFilter(current_img, kernel_size)
			computeSNR(img, img_res, img_res_name)
			cv2.imwrite(img_res_name, img_res)
	
	# (e) Use both opening-then-closing and closing-then opening filter 
	# (using the octogonal 3-5-5-5-3 kernel, value = 0) on images generated by (a)(b)
	# kernel is a 3-5-5-5-3 octagon, where the orgin is at the center
	kernel = [    [-2, -1], [-2, 0], [-2, 1],
		[-1, -2], [-1, -1], [-1, 0], [-1, 1], [-1, 2],
		[0, -2],  [0, -1],  [0, 0],  [0, 1],  [0, 2],
		[1, -2],  [1, -1],  [1, 0],  [1, 1],  [1, 2],
				  [2, -1],  [2, 0],  [2, 1]]	
	imgs_name = ["gaussian_noise_amp_10", "gaussian_noise_amp_30", "salt_and_pepper_010", "salt_and_pepper_005"]
	imgs = [amp_10_img, amp_30_img, salt_and_pepper_010, salt_and_pepper_005]
	funcs = ["closing-then-opening", "opening-then-closing"]
	for (current_img_name, current_img) in zip(imgs_name, imgs):
		for func in funcs:	
			img_res_name = current_img_name + "_" + func + ".png"
			if func == "closing-then-opening":
				img_res = Opening(Closing(current_img, kernel), kernel)
			elif func == "opening-then-closing":
				img_res = Closing(Opening(current_img, kernel), kernel)
			computeSNR(img, img_res, img_res_name)
			cv2.imwrite(img_res_name, img_res)



